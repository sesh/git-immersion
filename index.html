<!doctypehtml><meta charset=UTF-8><meta content="IE=edge"http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1"name=viewport><style>:root{--imml-text-light:#333333;--imml-text-dark:#eeeeee;--imml-background-light:#ffffff;--imml-background-dark:#121212;--imml-accent-light:dodgerblue;--imml-accent-dark:dodgerblue}:root{--imml-background:var(--imml-background-light);--imml-text:var(--imml-text-light);--imml-text-inverse:var(--imml-text-dark);--imml-accent:var(--imml-accent-light)}@media (prefers-color-scheme:dark){:root{--imml-background:var(--imml-background-dark);--imml-text:var(--imml-text-dark);--imml-text-inverse:var(--imml-text-light);--imml-accent:var(--imml-accent-dark)}}body,html{height:100%;width:100%;margin:0}body{font-family:sans-serif;min-height:100%;color:var(--imml-text);background:var(--imml-background)}.pages{margin:0 auto;max-width:600px;padding-left:1em;padding-right:1em}.pages .page{padding-top:2em;padding-bottom:10em}.page .breadcrumbs{font-family:monospace;text-transform:uppercase;font-size:small}p{line-height:22px}a{width:fit-content;color:var(--imml-accent);border-bottom:1px dotted var(--imml-accent);text-decoration:none}hr{border-style:solid;border-bottom:1px;margin-top:1em;margin-bottom:1em}blockquote{border-left:.5em solid var(--imml-text-inverse);padding:0 1em}blockquote p{font-style:italic}code{background:var(--imml-text-inverse);border-radius:.25em;padding:0 .25em;font-family:monospace;display:inline-block}pre code{padding:.5em .5em}pre{overflow-x:auto}img{max-width:100%}table{margin-top:.25em;border-collapse:collapse;width:100%}thead{text-align:left;font-weight:700}thead tr{border-bottom:1px solid}tr{border-bottom:1px dashed}td,th{padding:4px}</style><style>#imml a.portal:not(.inline){display:block}#imml .pages>.page,#imml .pages>.page:target~.page:last-child{display:none}#imml .pages>.page:target,#imml .pages>:last-child{display:block}#imml .pages>:last-child .breadcrumbs{visibility:hidden}</style><style class=imml>h2{margin-top:2em}pre code{min-width:100%;line-height:1.4em;box-sizing:border-box}pre{margin-bottom:2em}a.external:after{content:" ↗"}.language-output{color:#8ce99a;background-color:#212529}#imml a.portal:not(.inline){margin-bottom:.4em}</style><title>All code is managed with a version control system</title><div id=imml><div class=pages><div class=page id="LAB-01: Getting things installed"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-01: Getting things installed</span></div><h2>Install Homebrew</h2><p>On MacOS we will use <a href=https://brew.sh class=external target=_blank>Homebrew</a> to manage the installation of most development related packages. Homebrew (or simply <code>brew</code>) is a package manager that lets you install a wide range of open source and binary packages in a consistent way.<p>Get <code>brew</code> installed with a <a href=https://sandstorm.io/news/2015-09-24-is-curl-bash-insecure-pgp-verified-install class=external target=_blank><code>curl|bash</code></a>. Open your terminal and use the command below to run the installer.<pre><code>> /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
</code></pre><p>You can check out the detailed installation instructions on the Homebrew website. That's also where you'll want to go to discover packages and get help.<p>For now we'll really only be using the <code>install</code> command.<h2>Install Git</h2><p>Now that Homebrew is installed, use that to get Git installed.<pre><code>> brew install git
</code></pre><p>You can check that git is working properly by executing it with the <code>--version</code> flag.<pre><code>> git --version
</code></pre><p>Next: <a href="#LAB-02: Github setup"class="portal inline">LAB-02: Github setup</a></div><div class=page id="LAB-02: Github setup"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-02: Github setup</span></div><h2>Set up your Github account</h2><p>Head to <a href=https://github.com class=external target=_blank>github.com</a> and sign up for a new account with your work email address. Select a username that you wouldn't mind a client seeing (though, that's pretty unlikely). Use a secure password generated by your password manager of choice.<p>If you have an active Github presence then you should feel free to add a link to your personal account in the descirption for your new work account.<p>Setting up a new account for work is a great example of how we want to keep your personal and work accounts separate.<h2>Add MFA to your account</h2><p>It's good practice to use MFA for all sites that have it available. This is critically important when our confidential information is at play.<p>Head to your account settings and set up your mobile device or hardware token as a second factor. You should already have <a href=https://support.microsoft.com/en-au/account-billing/download-and-install-the-microsoft-authenticator-app-351498fc-850a-45da-b7b6-27e523b8702a class=external target=_blank>Microsoft Authenticator</a> installed to use as a second factor for your work email account.<p>If you already have <a href=https://authy.com/features/ class=external target=_blank>Authy</a>, <a href="https://support.google.com/accounts/answer/1066447?hl=en&ref_topic=2954345"class=external target=_blank>Google Authenticator</a> or another TOTP application installed then feel free to use that instead.<h2>Generate and add an SSH key</h2><p>Follow Github's detailed instructions for <a href=https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent class=external target=_blank>generating and adding a new SSH key</a> to your account.<h2>Get added to our Github organisation</h2><p>Send a quick message to one of today's hosts to be added to the Github organisation. Once you're there you'll be able to see some of our internal projects (including the respository for this workshop!)<p>Next: <a href="#LAB-03: Configure Git"class="portal inline">LAB-03: Configure Git</a></div><div class=page id="LAB-03: Configure Git"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-03: Configure Git</span></div><h2>Set up your global Git configuration</h2><p>The <code>.gitconfig</code> file in your home directory lets you control <em>global</em> configuration for git. You can edit the file manually, or use <code>git config</code> on the command line to modify it.<p>Start by setting your name and email address:<pre><code>> git config user.email &lt;your-work-email>
> git config user.name &lt;your-full-name>
</code></pre><p>You can use <code>cat</code> to display the output of your <code>.gitconfig</code> file:<pre><code>> cat ~/.gitconfig
</code></pre><p>Next: <a href="#LAB-04: Create a Project"class="portal inline">LAB-04: Create a Project</a></div><div class=page id="LAB-04: Create a Project"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-04: Create a Project</span></div><h2>Create a "Hello, World" program</h2><p>Let's start by creating an empty directory named “hello”.<pre><code>> mkdir hello
> cd hello
</code></pre><p>Then add the following code to a new file called <code>hello.rb</code>:<pre><code>puts "Hello, World"
</code></pre><p>It's optional, but at this point you can execute this file with the <code>ruby</code> interpreter to see the output.<pre><code>> ruby hello.rb
</code></pre><p><strong>Congratulations</strong>, you're a ruby development now :D.<h2>Create the Repository</h2><p>You now have a directory with a single file. To create a git repository from that directory, run the git init command.<pre><code>> git init
</code></pre><pre><code class=language-output>> git init
Initialized empty Git repository in /Users/jim/Downloads/git_tutorial/work/hello/.git/
</code></pre><h2>Add the program to the repository</h2><p>Now let’s add the “Hello, World” program to the repository.<pre><code>> git add hello.rb
> git commit -m "First Commit"
</code></pre><pre><code class=language-output>> git add hello.rb
> git commit -m "First Commit"
[main (root-commit) 19f3881] First Commit
1 file changed, 1 insertion(+)
create mode 100644 hello.rb
</code></pre><p>Next: <a href="#LAB-05: Checking Status"class="portal inline">LAB-05: Checking Status</a></div><div class=page id="LAB-05: Checking Status"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-05: Checking Status</span></div><h2>Check the status of the repository</h2><p>Use the <code>git status</code> command to check the current status of the repository.<pre><code>> git status
</code></pre><pre><code class=language-output>> git status
On branch main
nothing to commit, working tree clean
</code></pre><p>The status command reports that there is nothing to commit. This means that the repository has all the current state of the working directory. There are no outstanding changes to record.<p>We will use the <code>git status</code> command to continue to monitor the state between the repository and the working directory.<p>Next: <a href="#LAB-06: Making Changes"class="portal inline">LAB-06: Making Changes</a></div><div class=page id="LAB-06: Making Changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-06: Making Changes</span></div><h2>Change the "Hello, World" program</h2><p>It’s time to change our hello program to take an argument from the command line. Change the file to be:<pre><code class=language-ruby>puts "Hello, #{ARGV.first}!"
</code></pre><h2>Check the status</h2><p>Now check the status of the working directory.<pre><code>> git status
</code></pre><pre><code class=language-output>> git status
On branch main
Changes not staged for commit:
(use "git add &lt;file>..." to update what will be committed)
(use "git restore &lt;file>..." to discard changes in working directory)
    modified:   hello.rb

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre><p>The first thing to notice is that git knows that the <code>hello.rb</code> file has been modified, but git has not yet been notified of these changes.<p>Also notice that the status message gives you hints about what you need to do next. If you want to add these changes to the repository, then use the <code>git add</code> command. Otherwise the <code>git restore</code> command can be used to discard the changes.<p>Next: <a href="#LAB-07: Staging Changes"class="portal inline">LAB-07: Staging Changes</a></div><div class=page id="LAB-07: Staging Changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-07: Staging Changes</span></div><h2>Add changes</h2><p>Now tell git to stage the changes. Then, check the status.<pre><code>> git add hello.rb
> git status
</code></pre><p>You should see:<pre><code class=language-output>> git add hello.rb
> git status
On branch main
Changes to be committed:
(use "git restore --staged &lt;file>..." to unstage)
    modified:   hello.rb
</code></pre><p>The change to the <code>hello.rb</code> file has been staged. This means that git now knows about the change, but the change hasn’t been permanently recorded in the repository yet. The next commit operation will include the staged changes.<p>If you decide you don’t want to commit that change after all, the status command reminds you that the <code>git restore</code> command can be used to unstage that change.<p>Next: <a href="#LAB-08: Staging and Committing"class="portal inline">LAB-08: Staging and Committing</a></div><div class=page id="LAB-08: Staging and Committing"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-08: Staging and Committing</span></div><h2>Staging and Committing</h2><p>A separate staging step in git is in line with the philosophy of getting out of the way until you need to deal with source control. You can continue to make changes to your working directory, and then at the point you want to interact with source control, git allows you to record your changes in small commits that record exactly what you did.<p>For example, suppose you edited three files (<code>a.rb</code>, <code>b.rb</code>, and <code>c.rb</code>). Now you want to commit all the changes, but you want the changes in <code>a.rb</code> and <code>b.rb</code> to be a single commit, while the changes to <code>c.rb</code> are not logically related to the first two files and should be a separate commit.<p>You could do the following:<pre><code>> git add a.rb
> git add b.rb
> git commit -m "Changes for a and b"
</code></pre><pre><code>git add c.rb
git commit -m "Unrelated change to c"
</code></pre><p>By separating staging and committing, you have the ability to easily fine tune what goes into each commit.<p>Next: <a href="#LAB-09: Committing Changes"class="portal inline">LAB-09: Committing Changes</a></div><div class=page id="LAB-09: Committing Changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-09: Committing Changes</span></div><h2>Commit the change</h2><p>Ok, enough about staging. Let’s commit what we have staged to the repository.<p>When you used <code>git commit</code> previously to commit the initial version of the <code>hello.rb</code> file to the repository, you included the <code>-m</code> flag that gave a comment on the command line. The commit command will allow you to interactively edit a comment for the commit. Let’s try that now.<p>If you omit the <code>-m</code> flag from the command line, git will pop you into the editor of your choice. The editor is chosen from the following list (in priority order):<ul><li>GIT_EDITOR environment variable<li>core.editor configuration setting<li>VISUAL environment variable<li>EDITOR environment variable</ul><p>I have the EDITOR variable set to <code>nano</code>.<p>So commit now and check the status.<pre><code>> git commit
</code></pre><pre><code class=language-output>
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch main
# Changes to be committed:
#    modified:   hello.rb
#
</code></pre><p>On the first line, enter the comment: “Using ARGV”. Save the file and exit the editor. You should see output similar to the following.<pre><code class=language-output>> git commit
[main 2eac0b2] Using ARGV
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><h2>Check the status</h2><p>Finally, let's check the status again.<pre><code>> git status
</code></pre><pre><code class=language-output>> git status
On branch main
nothing to commit, working tree clean
</code></pre><p>The working directory is clean and ready for you to continue.<p>Next: <a href="#LAB-10: Changes, not Files"class="portal inline">LAB-10: Changes, not Files</a></div><div class=page id="LAB-10: Changes, not Files"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-10: Changes, not Files</span></div><h2>Changes, not Files</h2><p>Most source control systems work with files. You add a file to source control and the system will track changes to the file from that point on.<p>Git focuses on the changes to a file rather than the file itself. When you say git add file, you are not telling git to add the file to the repository. Rather you are saying that git should make note of the current state of that file to be committed later.<p>We will attempt to explore that difference in this lab.<h2>First Change: Allow a default name</h2><p>Change the “Hello, World” program to have a default value if a command line argument is not supplied.<pre><code>name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><h2>Add this change</h2><p>Now add this change to git's staging area.<pre><code>> git add hello.rb
</code></pre><h2>Second change: Add a comment</h2><p>Now add a comment to the “Hello, World” program.<pre><code># Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><h2>Check the current status</h2><pre><code>> git status
</code></pre><p>You should see:<pre><code class=language-output>git status
On branch main
Changes to be committed:
(use "git restore --staged &lt;file>..." to unstage)
    modified:   hello.rb

Changes not staged for commit:
(use "git add &lt;file>..." to update what will be committed)
(use "git restore &lt;file>..." to discard changes in working directory)
    modified:   hello.rb
</code></pre><p>Notice how <code>hello.rb</code> is listed twice in the status. The first change (adding a default) is staged and is ready to be committed. The second change (adding a comment) is unstaged. If you were to commit right now, the comment would not be saved in the repository.<p>Let’s try that.<h2>Committing</h2><p>Commit the staged change (the default value), and then recheck the status.<pre><code>> git commit -m "Added a default value"
> git status
</code></pre><p>You should see:<pre><code class=language-output>> git commit -m "Added a default value"
[main 58498b1] Added a default value
1 file changed, 3 insertions(+), 1 deletion(-)
On branch main
Changes not staged for commit:
(use "git add &lt;file>..." to update what will be committed)
(use "git restore &lt;file>..." to discard changes in working directory)
    modified:   hello.rb

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre><p>The status command is telling you that <code>hello.rb</code> has unrecorded changes, but is no longer in the staging area.<h2>Add the second change</h2><p>Now add the second change to the staging area, then run <code>git status</code>.<pre><code>> git add .
> git status
</code></pre><p>We just used the current directory (‘.’) as the file to add. This is a really convenient shortcut for adding in all the changes to the files in the current directory and below. But since it adds everything, it is a really good idea to check the status before doing an <code>add .</code>, just to make sure you don’t add any file that is not intended.<p>You should see:<pre><code class=language-output>> git status
On branch main
Changes to be committed:
(use "git restore --staged &lt;file>..." to unstage)
    modified:   hello.rb
</code></pre><p>Now the second change has been staged and is ready to commit.<h2>Commit the second change</h2><pre><code>> git commit -m "Added a comment"
</code></pre><p>Next: <a href="#LAB-11: History"class="portal inline">LAB-11: History</a></div><div class=page id="LAB-11: History"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-11: History</span></div><h2>History</h2><p>Getting a listing of what changes have been made is the function of the git log command.<pre><code>> git log
</code></pre><p>You should see:<pre><code class=language-output>> git log
commit c51cd709b284ba82ae2c7d1578e242cd11dc8a0e
Author: Git Committer &lt;me@example.org>
Date:   Mon Aug 15 14:54:42 2022 +1000

    Added a comment

commit 58498b15c685b8332eb2031764cb2fd80e18a886
Author: Git Committer &lt;me@example.org>
Date:   Mon Aug 15 14:54:42 2022 +1000

    Added a default value

commit a03ff84b97f40549ea1e21c4680a2fd3f30eeec4
Author: Git Committer &lt;me@example.org>
Date:   Mon Aug 15 14:54:42 2022 +1000

    Using ARGV

commit 19f3881f40ceb5fa20328bf94a749b2c2ba650d7
Author: Git Committer &lt;me@example.org>
Date:   Mon Aug 15 14:54:42 2022 +1000

    First Commit
</code></pre><h2>One Line Histories</h2><p>You have a great deal of control over exactly what the <code>log</code> command displays. I like the one line format:<pre><code>> git log --pretty=oneline
</code></pre><pre><code class=language-output>> git log --pretty=oneline
c51cd709b284ba82ae2c7d1578e242cd11dc8a0e Added a comment
58498b15c685b8332eb2031764cb2fd80e18a886 Added a default value
a03ff84b97f40549ea1e21c4680a2fd3f30eeec4 Using ARGV
19f3881f40ceb5fa20328bf94a749b2c2ba650d7 First Commit
</code></pre><h2>Controlling Which Entries are Displayed</h2><p>There are a lot of options for selecting which entries are displayed in the log. Play around with the following options:<pre><code>> git log --pretty=oneline --max-count=2
> git log --pretty=oneline --since='5 minutes ago'
> git log --pretty=oneline --until='5 minutes ago'
> git log --pretty=oneline --author=&lt;your name>
> git log --pretty=oneline --all
</code></pre><p>See man git-log for all the details.<h2>Getting Fancy</h2><p>Here’s what I use to review the changes made in the last week. I’ll add <code>--author=&lt;my-name></code> if I only want to see changes I made.<pre><code>> git log --all --pretty=format:'%h %cd %s (%an)' --since='7 days ago'
</code></pre><h2>The Ultimate Log Format</h2><p>Over time, I’ve decided that I like the following log format for most of my work.<pre><code>git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
</code></pre><p>It looks like this:<pre><code class=language-output>> git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
* c51cd70 2022-08-15 | Added a comment (HEAD -> main) [Git Committer]
* 58498b1 2022-08-15 | Added a default value [Git Committer]
* a03ff84 2022-08-15 | Using ARGV [Git Committer]
* 19f3881 2022-08-15 | First Commit [Git Committer]
</code></pre><p>Let’s look at it in detail:<ul><li>`--pretty="..."`` defines the format of the output.<li><code>%h</code> is the abbreviated hash of the commit<li><code>%d</code> are any decorations on that commit (e.g. branch heads or tags)<li><code>%ad</code> is the author date<li><code>%s</code> is the comment<li><code>%an</code> is the author name<li><code>--graph</code> informs git to display the commit tree in an ASCII graph layout<li><code>--date=short</code> keeps the date format nice and short</ul><p>This is a lot to type every time you want to see the log. Fortunately we will learn about git aliases in the next lab.<h2>Other Tools</h2><p>Both <code>gitx</code> (for Macs) and <code>gitk</code> (any platform) are useful in exploring log history.<p>Next: <a href="#LAB-12: Aliases"class="portal inline">LAB-12: Aliases</a></div><div class=page id="LAB-12: Aliases"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-12: Aliases</span></div><h2>Common Aliases</h2><p><code>git status</code>, <code>git add</code>, <code>git commit</code>, <code>git switch</code> and <code>git checkout</code> are such common commands that it is useful to have abbreviations for them.<p>Add the following to the .gitconfig file in your <code>$HOME</code> directory:<pre><code>\[alias]  # remove this comment, and the leading slash (it breaks the layout!)
    co = checkout
    ci = commit
    st = status
    br = branch
    sw = switch
    hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
    type = cat-file -t
    dump = cat-file -p
</code></pre><p>We’ve covered the commit and status commands already. And we just covered the <code>log</code> command in the previous lab. The <code>checkout</code> command will be coming up soon.<p>With these aliases defined in the <code>.gitconfig</code> file you can type <code>git co</code> wherever you used to have to type <code>git checkout</code>. Likewise with <code>git st</code> for <code>git status</code> and <code>git ci</code> for <code>git commit</code>. And best of all, <code>git hist</code> will allow you to avoid the really long log command.<p>Go ahead and give the new commands a try.<h2>Define the hist alias in your .gitconfig file</h2><p>For the most part, I will continue to type out the full command in these instructions. The only exception is that I will use the <code>hist</code> alias defined above anytime we need to see the <code>git log</code> output. Make sure you have a <code>hist</code> alias setup in your .gitconfig file before continuing if you wish to follow along.<h2><code>Type</code> and <code>Dump</code></h2><p>We’ve added a few aliases for commands we haven’t covered yet. The <code>git branch</code> command will be coming up soon. And the <code>git cat-file</code> command is useful for exploring git, which we will see in a little while.<p>Next: <a href="#LAB-13: Getting Old Versions"class="portal inline">LAB-13: Getting Old Versions</a></div><div class=page id="LAB-13: Getting Old Versions"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-13: Getting Old Versions</span></div><h2>Getting Old Versions</h2><p>Going back in history is very easy. The checkout command will copy any snapshot from the repository to the working directory.<h2>Get the hashes for previous versions</h2><pre><code>git hist
</code></pre><p><strong>Note:</strong> You did remember to define <code>hist</code> in your <code>.gitconfig</code> file, right? If not, review the lab on aliases.<pre><code class=language-output>> git hist
* db1f4d1 2022-08-16 | Added a comment (HEAD -> main) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value  [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Examine the log output and find the hash for the first commit. It should be the last line of the <code>git hist</code> output. Use that hash code (the first 7 characters are enough) in the command below. Then check the contents of the hello.rb file.<pre><code>> git checkout &lt;hash>
> cat hello.rb
</code></pre><p>You should see something similar to:<pre><code class=language-output>> git checkout 19f3881
Note: switching to '19f3881'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

git switch -c &lt;new-branch-name>

Or undo this operation with:

git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 19f3881 First Commit
> cat hello.rb
puts "Hello, World"
</code></pre><p>The output of the <code>checkout</code> command explains the situation pretty well. Older versions of git will complain about not being on a local branch. In any case, don’t worry about that for now.<p>Notice the contents of the <code>hello.rb</code> file are the original contents.<h2>Return to the latest version in the main branch</h2><pre><code>> git switch main
> cat hello.rb
</code></pre><pre><code class=language-output>> git checkout main
Previous HEAD position was 19f3881 First Commit
Switched to branch 'main'
> cat hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><p><code>main</code> is the name of the default branch. By checking out a branch by name, you go to the latest version of that branch.<p>Next: <a href="#LAB-14: Tagging versions"class="portal inline">LAB-14: Tagging versions</a></div><div class=page id="LAB-14: Tagging versions"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-14: Tagging versions</span></div><h2>Tagging our first version</h2><p>Let’s call the current version of the hello program version 1 (v1).<pre><code>> git tag v1
</code></pre><p>Now you can refer to the current version of the program as <code>v1</code>.<h2>Tagging previous versions</h2><p>Let’s tag the version immediately prior to the current version <code>v1-beta</code>. First we need to checkout the previous version. Rather than look up the hash, we will use the `^`` notation to indicate “the parent of v1”.<p>If the <code>v1^`` notation gives you any trouble, you can also try</code>v1~1`, which will reference the same version. This notation means “the first ancestor of v1”.<pre><code>> git checkout v1^
> cat hello.rb
</code></pre><pre><code class=language-output>> git checkout v1^
Note: switching to 'v1^'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

git switch -c &lt;new-branch-name>

Or undo this operation with:

git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 58498b1 Added a default value
> cat hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><p>See, this is the version with the default value before we added the comment. Let’s make this v1-beta.<pre><code>> git tag v1-beta
</code></pre><h2>Checking Out by Tag Name</h2><p>Now try going back and forth between the two tagged versions.<pre><code>> git checkout v1
> git checkout v1-beta
</code></pre><pre><code class=language-output>> git checkout v1
Previous HEAD position was 58498b1 Added a default value
HEAD is now at c51cd70 Added a comment
> git checkout v1-beta
Previous HEAD position was c51cd70 Added a comment
HEAD is now at 58498b1 Added a default value
</code></pre><h2>Viewing Tags using the tag command</h2><p>You can see what tags are available using the <code>git tag</code> command.<pre><code>git tag
</code></pre><pre><code class=language-output>> git tag
v1
v1-beta
</code></pre><h2>Viewing Tags in the Logs</h2><p>You can also check for tags in the log.<pre><code>> git hist main --all
</code></pre><pre><code class=language-output>> git hist main --all
* db1f4d1 2022-08-16 | Added a comment (HEAD -> main, tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>You can see both tags (<code>v1</code> and <code>v1-beta</code>) listed in the log output, along with the branch name (<code>main</code>). Also <code>HEAD</code> shows you the currently checked out commit (which is <code>v1-beta</code> at the moment).<p>Next: <a href="#LAB-15: Undoing Local Changes Before Staging"class="portal inline">LAB-15: Undoing Local Changes Before Staging</a></div><div class=page id="LAB-15: Undoing Local Changes Before Staging"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-15: Undoing Local Changes Before Staging</span></div><h2>Undoing Local Changes Before Staging</h2><p>Let's learn how to roll back a change we've made to the code.<h2>Checkout main</h2><p>Make sure you are back on the latest commit in main before continuing.<pre><code>> git checkout main
</code></pre><h2>Change hello.rb</h2><p>Sometimes you have modified a file in your local working directory and you wish to just revert to what has already been committed. The checkout command will handle that.<p>Change hello.rb to have a bad comment.<pre><code># This is a bad comment.  We want to revert it.
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><h2>Check the status</h2><p>First, check the status of the working directory.<pre><code>> git status
</code></pre><pre><code class=language-output>> git status
On branch main
Changes not staged for commit:
(use "git add &lt;file>..." to update what will be committed)
(use "git restore &lt;file>..." to discard changes in working directory)
    modified:   hello.rb

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre><p>We see that the hello.rb file has been modified, but hasn’t been staged yet.<h2>Restore the changes to the working directory</h2><p>Use the <code>restore</code> command to go back to the repository's version of the <code>hello.rb</code> file.<pre><code>> git restore hello.rb
> git status
> cat hello.rb
</code></pre><pre><code class=language-output>> git restore hello.rb
> git status
On branch main
nothing to commit, working tree clean
> cat hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><p>The status command shows us that there are no outstanding changes in the working directory. And the “bad comment” is no longer part of the file contents.<p>Next: <a href="#LAB-16: Undoing Local Changes Before Committing"class="portal inline">LAB-16: Undoing Local Changes Before Committing</a></div><div class=page id="LAB-16: Undoing Local Changes Before Committing"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-16: Undoing Local Changes Before Committing</span></div><h2>Change the file and stage the change</h2><p>Modify the <code>hello.rb</code> again file to have a bad comment.<pre><code># This is an unwanted but staged comment
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><p>And then go ahead and stage it.<pre><code>> git add hello.rb
</code></pre><h2>Check the status</h2><pre><code>> git status
</code></pre><pre><code class=language-output>git status
On branch main
Changes to be committed:
(use "git restore --staged &lt;file>..." to unstage)
    modified:   hello.rb
</code></pre><p>The status output shows that the change has been staged and is ready to be committed. Like a lot of <code>git</code> commands, it also gives us a hint that we can use to go back.<h2>Restore the staging area</h2><p>Fortunately the status output tells us exactly what we need to do to unstage the change.<pre><code>> git restore --staged hello.rb
</code></pre><p>The <code>restore --staged</code> command takes the staging area back to be whatever is in HEAD. This clears the staging area of the change we just staged.<p>Using <code>restore --staged</code> doesn’t change the working directory. So the working directory still has the unwanted comment in it. We can use the <code>restore</code> command of the previous lab to remove the unwanted change from the working directory.<h2>Restor the committed version</h2><pre><code>> git restore hello.rb
> git status
</code></pre><pre><code class=language-output>> git status
On branch main
nothing to commit, working tree clean
</code></pre><p>And our working directory is clean once again.<p>Next: <a href="#LAB-17: Undoing Committed Changes"class="portal inline">LAB-17: Undoing Committed Changes</a></div><div class=page id="LAB-17: Undoing Committed Changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-17: Undoing Committed Changes</span></div><h2>Undoing Commits</h2><p>Sometimes you realise that a change that you have already committed was not correct and you wish to undo that commit. There are several ways of handling that issue, and the way we are going to use in this lab is always safe.<p>Essentially we will undo the commit by creating a new commit that reverses the unwanted changes.<h2>Change the file and commit it</h2><p>Change the hello.rb file to the following.<pre><code># This is an unwanted but committed change
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><p>Then commit the change.<pre><code>> git add hello.rb
> git commit -m "Oops, we didn't want this commit"
</code></pre><h2>Create a Reverting Commit</h2><p>To undo a committed change, we need to generate a commit that removes the changes introduced by our unwanted commit.<pre><code>git revert HEAD
</code></pre><p>This will pop you into the editor. You can edit the default commit message or leave it as is. Save and close the file. You should see the following.<pre><code class=language-output>> git revert HEAD
[main 0110f9a] Revert "Oops, we didn't want this commit"
Date: Mon Aug 15 14:54:43 2022 +1000
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><p>Since we were undoing the very last commit we made, we were able to use <code>HEAD</code> as the argument to revert. We can revert any arbitrary commit earlier in history by simply specifying its hash value.<h2>Check the log</h2><p>Checking the log shows both the unwanted and the reverting commits in our repository.<pre><code>> git hist
</code></pre><pre><code class=language-output>> git hist
* 567e59e 2022-08-16 | Revert "Oops, we didn't want this commit" (HEAD -> main) [Brenton Cleeland]
* 148b282 2022-08-16 | Oops, we didn't want this commit [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>This technique will work with any commit (although you may have to resolve conflicts). It is safe to use even on branches that are publicly shared on remote repositories.<p>Next: <a href="#LAB-18: Removing Commits from a Branch"class="portal inline">LAB-18: Removing Commits from a Branch</a></div><div class=page id="LAB-18: Removing Commits from a Branch"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-18: Removing Commits from a Branch</span></div><h2>Removing Commits from a Branch</h2><p>The <code>revert</code> command of the previous section is a powerful command that lets us undo the effects of any commit in the repository. However, both the original commit and the “undoing” commit are visible in the branch history (using the <code>git log</code> command).<p>Often we make a commit and immediately realize that it was a mistake. It would be nice to have a “take back” command that would allow us to pretend that the incorrect commit never happened. The “take back” command would even prevent the bad commit from showing up the <code>git log</code> history. It would be as if the bad commit never happened.<h2>The <code>reset</code> command</h2><p>We’ve already seen the <code>restore</code> command and have used it to set the staging area to be consistent with a given commit (we used the HEAD commit in our previous lab). The <code>reset</code> command is a similar command that lets us completely remove commits from a branch.<p>When given a commit reference (i.e. a hash, branch or tag name), the <code>reset</code> command will:<ol><li>Rewrite the current branch to point to the specified commit<li>Optionally reset the staging area to match the specified commit<li>Optionally reset the working directory to match the specified commit</ol><h2>Check Our History</h2><p>Let's do a quick check of our commit history.<pre><code>> git hist
</code></pre><pre><code class=language-output>> git hist
* 567e59e 2022-08-16 | Revert "Oops, we didn't want this commit" (HEAD -> main) [Brenton Cleeland]
* 148b282 2022-08-16 | Oops, we didn't want this commit [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>We see that we have an “Oops” commit and a “Revert Oops” commit as the last two commits made in this branch. Let’s remove them using reset.<h2>First, Mark this Branch</h2><p>But before we remove the commits, let’s mark the latest commit with a tag so we can find it again.<pre><code>> git tag oops
</code></pre><h2>Reset to Before Oops</h2><p>Looking at the log history (above), we see that the commit tagged <code>v1</code> is the commit right before the bad commit. Let’s reset the branch to that point. Since that branch is tagged, we can use the tag name in the reset command (if it wasn’t tagged, we could just use the hash value).<pre><code>> git reset --hard v1
> git hist
</code></pre><pre><code class=language-output>git reset --hard v1
HEAD is now at db1f4d1 Added a comment
* db1f4d1 2022-08-16 | Added a comment (HEAD -> main, tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Our main branch now points to the v1 commit and the Oops commit and the Revert Oops commit are no longer in the branch. The <code>--hard</code> parameter indicates that the working directory should be updated to be consistent with the new branch head.<h2>Nothing is Ever Lost</h2><p>But what happened to the bad commits? It turns out that the commits are still in the repository. In fact, we can still reference them. Remember that at the beginning of this lab we tagged the reverting commit with the tag “oops”. Let’s look at all the commits.<pre><code>git hist --all
</code></pre><pre><code class=language-output>git hist --all
* 567e59e 2022-08-16 | Revert "Oops, we didn't want this commit" (tag: oops) [Brenton Cleeland]
* 148b282 2022-08-16 | Oops, we didn't want this commit [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (HEAD -> main, tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Here we see that the bad commits haven’t disappeared. They are still in the repository. It’s just that they are no longer listed in the main branch. If we hadn’t tagged them, they would still be in the repository, but there would be no way to reference them other than using their hash names. Commits that are unreferenced remain in the repository until the system runs the garbage collection software.<h2>Dangers of Reset</h2><p>Resets on local branches are generally safe. Any “accidents” can usually be recovered from by just resetting again with the desired commit.<p>However, if the branch is shared on remote repositories, resetting can confuse other users sharing the branch. As a general rule you should <code>revert</code> not <code>reset</code> if you have shared your branch by pushing it to a remote repository.<h2>Removing tag oops</h2><p>The oops tag has served its purpose. Let’s remove it and allow the commits it referenced to be garbage collected.<pre><code>> git tag -d oops
> git hist --all
</code></pre><pre><code class=language-output>> git tag -d oops
Deleted tag 'oops' (was 567e59e)
> git hist --all
* db1f4d1 2022-08-16 | Added a comment (HEAD -> main, tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>The oops tag is no longer listed in the repository.<p>Next: <a href="#LAB-19: Ammending Commits"class="portal inline">LAB-19: Ammending Commits</a></div><div class=page id="LAB-19: Ammending Commits"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-19: Ammending Commits</span></div><h2>Change the program, then commit</h2><p>Let's add a simple author comment to the program.<pre><code># Default is World
# Author: &lt;your name>
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><pre><code>> git add hello.rb
> git commit -m "Add an author comment"
</code></pre><h2>Oops, Should have an Email</h2><p>After you make the commit, you realize that any good author comment should have an email included. Update the hello program to include an email.<pre><code># Default is World
# Author: &lt;your name> (me@example.org)
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><h2>Ammend the Previous Commit</h2><p>We really don’t want a separate commit for just the email. Let’s amend the previous commit to include the email change.<pre><code>> git add hello.rb
> git commit --amend -m "Add an author/email comment"
</code></pre><pre><code class=language-output>> git add hello.rb
> git commit --amend -m "Add an author/email comment"
[main af90521] Add an author/email comment
Date: Mon Aug 15 14:54:43 2022 +1000
1 file changed, 2 insertions(+), 1 deletion(-)
</code></pre><h2>Review the History</h2><pre><code>> git hist
</code></pre><pre><code>> git hist
* af90521 2022-08-16 | Add an author/email comment (HEAD -> main) [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>We can see the original “author” commit is now gone, and it is replaced by the “author/email” commit. You can achieve the same effect by resetting the branch back one commit and then recommitting the new changes.<p>Similarly to the <code>reset</code> command in the previous lab, you need to be careful not to ammend commits that you've already shared with others by pushing to a remote repository.<p>Next: <a href="#LAB-20: Moving Files"class="portal inline">LAB-20: Moving Files</a></div><div class=page id="LAB-20: Moving Files"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-20: Moving Files</span></div><h2>Move the hello.rb file into a lib directory</h2><p>We are now going to build up the structure of our little repository. Let’s move the program into a lib directory.<pre><code>> mkdir lib
> git mv hello.rb lib
> git status
</code></pre><pre><code class=language-output>> mkdir lib
> git mv hello.rb lib
> git status
On branch main
Changes to be committed:
(use "git restore --staged &lt;file>..." to unstage)
    renamed:    hello.rb -> lib/hello.rb
</code></pre><p>By using git to do the move, we inform git of 2 things<ol><li>That the file hello.rb has been deleted.<li>The file lib/hello.rb has been created.</ol><p>Both of these bits of information are immediately staged and ready to be committed. The <code>git status</code> command reports that the file has been moved.<h2>Another way of moving files</h2><p>One of the nice things about git is that you can forget about source control until the point you are ready to start committing code. What would happen if we used the operating system command to move the file instead of the git command?<p>It turns out the following set of commands is identical to what we just did. It’s a bit more work, but the result is the same.<p>We could have done:<pre><code>> mkdir lib
> mv hello.rb lib
> git add lib/hello.rb
> git rm hello.rb
</code></pre><h2>Commit the new directory</h2><p>Let's commit this change before we move on.<pre><code>> git commit -m "Moved hello.rb to lib"
</code></pre><p>Next: <a href="#LAB-21: Git Internals - The .git Directory"class="portal inline">LAB-21: Git Internals - The .git Directory</a></div><div class=page id="LAB-21: Git Internals - The .git Directory"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-21: Git Internals - The .git Directory</span></div><h2>The .git Directory</h2><p>Let's take a quick detour and explore some of git's internals. First, from the root of your project directory:<pre><code>> ls -C .git
</code></pre><pre><code class=language-output>> ls -C .git
COMMIT_EDITMSG    config        index        objects
HEAD        description    info        packed-refs
ORIG_HEAD    hooks        logs        refs
</code></pre><p>This is the magic directory where all the git “stuff” is stored. Let’s peek in the objects directory.<h2>The Object Store</h2><pre><code>> ls -C .git/objects
</code></pre><pre><code class=language-output>> ls -C .git/objects
01    11    27    43    69    7d    98    af    c5    info
05    19    28    58    6b    94    9c    b5    e4    pack
09    24    37    59    78    97    a0    c4    e7
</code></pre><p>You should see a bunch of directories with 2 letter names. The directory names are the first two letters of the sha1 hash of the object stored in git.<h2>Deeper into the Object Store</h2><pre><code>> ls -C .git/objects/&lt;dir>
</code></pre><pre><code class=language-output>> ls -C .git/objects/01
10f9a5cf0047ac7cb1938734e238f48a47ffb4
</code></pre><p>Look in one of the two-letter directories. You should see some files with 38-character names. These are the files that contain the objects stored in git. These files are compressed and encoded, so looking at their contents directly won’t be very helpful, but we will take a closer look in a bit.<h2>Config File</h2><pre><code>> cat .git/config
</code></pre><pre><code class=language-output>> cat .git/config
\[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
\[user]
    name = Git User
    email = me@example.org
</code></pre><p>This is a project-specific configuration file. Config entries in here will override the config entries in the .gitconfig file in your home directory, at least for this project.<h2>Branches and Tags</h2><pre><code>> ls .git/refs
> ls .git/refs/heads
> ls .git/refs/tags
> cat .git/refs/tags/v1

```output
> ls .git/refs
heads
tags
> ls .git/refs/heads
main
> ls .git/refs/tags
v1
v1-beta
> cat .git/refs/tags/v1
c51cd709b284ba82ae2c7d1578e242cd11dc8a0e
</code></pre><p>You should recognize the files in the tags subdirectory. Each file corresponds to a tag you created with the git tag command earlier. Its content is just the hash of the commit tied to the tag.<p>The heads directory is similar, but is used for branches rather than tags. We only have one branch at the moment, so all you will see is main in this directory.<h2>The HEAD File</h2><pre><code>> cat .git/HEAD

```output
> cat .git/HEAD
ref: refs/heads/main
</code></pre><p>The HEAD file contains a reference to the current branch. It should be a reference to main at this point.<p>Next: <a href="#LAB-22: Creating a Branch"class="portal inline">LAB-22: Creating a Branch</a></div><div class=page id="LAB-22: Creating a Branch"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-22: Creating a Branch</span></div><h2>Create a new branch</h2><p>It’s time to do a major rewrite of the hello world functionality. Since this might take awhile, you’ll want to put these changes into a separate branch to isolate them from changes in main.<p>Let’s call our new branch <code>greet</code>.<pre><code>> git checkout -b greet
> git status
</code></pre><p><strong>NOTE:</strong> <code>git checkout -b &lt;branchname></code> is a shortcut for <code>git branch &lt;branchname></code> followed by a <code>git switch &lt;branchname></code>.<p>Notice that the git status command reports that you are on the <code>greet</code> branch.<h2>Changes for Greet: Add a Greeter class</h2><p>Create a new file called <code>lib/greeter.rb</code> with the following content:<pre><code>class Greeter
    def initialize(who)
        @who = who
    end
    def greet
        "Hello, #{@who}"
    end
end
</code></pre><p>Then add and commit the new file:<pre><code>> git add lib/greeter.rb
> git commit -m "Added greeter class"
</code></pre><h2>Changes for Greet: Modify the main program</h2><p>Update <code>hello.rb</code> to use the greeter class:<pre><code>require_relative 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
</code></pre><p>Add and commit this change as well:<pre><code>> git add lib/hello.rb
> git commit -m "Hello uses Greeter"
</code></pre><h2>Up Next</h2><p>We now have a new branch called greet with 2 new commits on it. Next we will learn how to navigate and switch between branches.<p>Next: <a href="#LAB-23: Navigating Branches"class="portal inline">LAB-23: Navigating Branches</a></div><div class=page id="LAB-23: Navigating Branches"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-23: Navigating Branches</span></div><h2>Navigating Branches</h2><p>You now have two branches in your project, the <code>*</code> in the output below indicates our current branch.<pre><code>> git branch
</code></pre><pre><code class=language-output>> git branch
* greet
  main
</code></pre><p>You can also use our <code>git hist --all</code> command to view the complete history with the branches.<h2>Switch to the Main Branch</h2><p>Just use the <code>git switch</code> command to change between branches.<pre><code>> git switch main
> cat lib/hello.rb
</code></pre><p>You are now on the main branch. You can tell because the hello.rb file doesn’t use the Greeter class.<pre><code class=language-output>> cat lib/hello.rb
# Default is World
# Author: &lt;your name> (me@example.org)
name = ARGV.first || "World"

puts "Hello, #{name}!"
</code></pre><h2>Switch Back to the Greet Branch.</h2><pre><code>> git switch greet
> cat lib/hello.rb
</code></pre><pre><code class=language-output>> cat lib/hello.rb
require_relative 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
</code></pre><p>The contents of the lib/hello.rb confirms we are back on the <code>greet</code> branch.<p>Next: <a href="#LAB-24: Changes in main"class="portal inline">LAB-24: Changes in main</a></div><div class=page id="LAB-24: Changes in main"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-24: Changes in main</span></div><h2>Switch to the main branch</h2><pre><code>> git switch main
</code></pre><h2>Create a README</h2><p>Create a new file called <code>README.md</code> with the following content:<pre><code>This is the Hello World example from the git tutorial.
</code></pre><h2>Commit the README to main</h2><pre><code>> git add README.md
> git commit -m "Added README.md"
</code></pre><p>Next: <a href="#LAB-25: Viewing Diverging Branches"class="portal inline">LAB-25: Viewing Diverging Branches</a></div><div class=page id="LAB-25: Viewing Diverging Branches"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-25: Viewing Diverging Branches</span></div><h2>View the Current Branches</h2><p>We now have two diverging branches in the repository. Use the <code>hist</code> alias we created earlier to view the branches and how they diverge.<pre><code class=language-output>> git hist --all
* 22d8379 2022-08-16 | Added README.md (HEAD -> main) [Brenton Cleeland]
| * 9ca04ea 2022-08-16 | Hello uses Greeter (greet) [Brenton Cleeland]
| * 34c8660 2022-08-16 | Added greeter class [Brenton Cleeland]
|/
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Here is our first chance to see the <code>--graph</code> option on <code>git hist</code> in action. Adding the <code>--graph</code> option to <code>git log</code> causes it to draw the commit tree using simple ASCII characters. We can see both branches (greet and main), and that the main branch is the current HEAD.<p>The <code>--all</code> flag makes sure that we see all the branches. The default is to show only the current branch.<p>Next: <a href="#LAB-26: Merging"class="portal inline">LAB-26: Merging</a></div><div class=page id="LAB-26: Merging"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-26: Merging</span></div><h2>Merge the branches</h2><p>Merging brings the changes in two branches together. Let’s go back to the greet branch and merge main onto greet.<pre><code>> git switch greet
> git merge main
> git hist --all
</code></pre><pre><code class=language-output>> git merge main
Merge made by the 'ort' strategy.
README.md | 1 +
1 file changed, 1 insertion(+)
create mode 100644 README.md
> git hist --all
*   4f17759 2022-08-16 | Merge branch 'main' into greet (HEAD -> greet) [Brenton Cleeland]
|\
| * 22d8379 2022-08-16 | Added README.md (main) [Brenton Cleeland]
* | 9ca04ea 2022-08-16 | Hello uses Greeter [Brenton Cleeland]
* | 34c8660 2022-08-16 | Added greeter class [Brenton Cleeland]
|/
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>By merging main into your greet branch periodically, you can pick up any changes to main and keep your changes in greet compatible with changes in the mainline.<p>However, it does produce ugly commit graphs. Later we will look at the option of rebasing rather than merging.<h2>Up Next</h2><p>But first, what if the changes in main conflict with the changes in greet?<p>Next: <a href="#LAB-27: Creating a Conflict"class="portal inline">LAB-27: Creating a Conflict</a></div><div class=page id="LAB-27: Creating a Conflict"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-27: Creating a Conflict</span></div><h2>Switch back to main and create a conflict</h2><p>Switch back to the main branch and make this change:<pre><code>> git switch main
</code></pre><p>Update <code>lib/hello.rb</code> with the following:<pre><code>puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
</code></pre><pre><code>> git add lib/hello.rb
> git commit -m "Made interactive"
</code></pre><p>We now have changes to <code>lib/hello.rb</code> on both of our active branches. A common situation if you have more than one person working on your codebase!<h2>View the branches</h2><pre><code>> git hist --all
</code></pre><pre><code>> git hist --all
* ef40b54 2022-08-16 | Made interactive (HEAD -> main) [Brenton Cleeland]
| *   4f17759 2022-08-16 | Merge branch 'main' into greet (greet) [Brenton Cleeland]
| |\
| |/
|/|
* | 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
| * 9ca04ea 2022-08-16 | Hello uses Greeter [Brenton Cleeland]
| * 34c8660 2022-08-16 | Added greeter class [Brenton Cleeland]
|/
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Main at commit “Added README” has been merged to the greet branch, but there is now an additional commit on main that has not been merged back to greet.<p>Next: <a href="#LAB-28: Resolving Conflicts"class="portal inline">LAB-28: Resolving Conflicts</a></div><div class=page id="LAB-28: Resolving Conflicts"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-28: Resolving Conflicts</span></div><h2>Merge main to greet</h2><p>Now go back to the greet branch and try to merge the new main.<pre><code>> git checkout greet
> git merge main
</code></pre><pre><code class=language-output>> git merge main
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
Automatic merge failed; fix conflicts and then commit the result.
</code></pre><p>If you open <code>lib/hello.rb</code> you will see git's conflict markers in the file:<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
require_relative 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
=======
puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
>>>>>>> main
</code></pre><p>The first section is the version on the head of the current branch (greet). The second section is the version on the main branch.<h2>Fix the Conflict</h2><p>You need to manually resolve the conflict. In this case we want to keep a version that supports both pieces of functionality. Modify <code>lib/hello.rb</code> to be the following:<pre><code>require_relative 'greeter'

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
</code></pre><h2>Commit the Conflict Resolution</h2><pre><code>> git add lib/hello.rb
> git commit -m "Merged main, fixed conflict."
</code></pre><pre><code class=language-output>> git add lib/hello.rb
> git commit -m "Merged main, fixed conflict."
[greet 8822978] Merged main, fixed conflict.
</code></pre><h2>Advanced Merging</h2><p>Git doesn't provide any graphical merge tools, but it will gladly work with any third party merge tool you with to use. Most modern editors (like VS Code) include merge tools that you can test. The <a href=https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration class=external target=_blank>Customising Git Configuration</a> section of the Git Book includes details about configuring Perforce as your default merge tool.<p>Next: <a href="#LAB-29: Merging vs Rebasing"class="portal inline">LAB-29: Merging vs Rebasing</a></div><div class=page id="LAB-29: Merging vs Rebasing"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-29: Merging vs Rebasing</span></div><h2>Merging vs Rebasing</h2><p>Let’s explore the differences between merging and rebasing. In order to do so, we will make a new change on the <code>main</code> branch, then use <code>git rebase</code> to move that onto our greet branch.<p>Start by switching to <code>main</code>:<pre><code>> git switch main
</code></pre><h2>Update the README.md</h2><p>Add a thank you to the original tutorial author in the README.md:<pre><code>This is the Hello World example from the git tutorial.

Thanks to Jim Weirich for the initial work on this tutorial for RailsConf 2010.
</code></pre><p>Now, lets commit that change on main.<pre><code>> git add README.md
> git commit -m "Add a thank you to Jim"
</code></pre><h2>View the history</h2><p>While still on the <code>main</code> branch, check the history.<pre><code>> git hist --all
</code></pre><pre><code class=language-output>git hist --all
* f6a7d74 2022-08-16 | Add a thank you to Jim (HEAD -> main) [Brenton Cleeland]
| *   8822978 2022-08-16 | Merged main, fixed conflict. (greet) [Brenton Cleeland]
| |\
| |/
|/|
* | ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
| *   4f17759 2022-08-16 | Merge branch 'main' into greet [Brenton Cleeland]
| |\
| |/
|/|
* | 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
| * 9ca04ea 2022-08-16 | Hello uses Greeter [Brenton Cleeland]
| * 34c8660 2022-08-16 | Added greeter class [Brenton Cleeland]
|/
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>In the log you can see the new commit at the top. Switch to the <code>greet</code> branch and view the history again, it should look the same.<pre><code>> git switch greet
> git hist --all
</code></pre><pre><code class=language-output>> git hist --all
* f6a7d74 2022-08-16 | Add a thank you to Jim (main) [Brenton Cleeland]
| *   8822978 2022-08-16 | Merged main, fixed conflict. (HEAD -> greet) [Brenton Cleeland]
| |\
| |/
|/|
* | ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
| *   4f17759 2022-08-16 | Merge branch 'main' into greet [Brenton Cleeland]
| |\
| |/
|/|
* | 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
| * 9ca04ea 2022-08-16 | Hello uses Greeter [Brenton Cleeland]
| * 34c8660 2022-08-16 | Added greeter class [Brenton Cleeland]
|/
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><h2>Rebase the change onto our branch</h2><p>This time we will use the rebase command instead of the merge command to bring in the changes from the main branch.<pre><code>> git rebase main
</code></pre><pre><code class=language-output>> git rebase main
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
error: could not apply 9ca04ea... Hello uses Greeter
hint: Resolve all conflicts manually, mark them as resolved with
hint: "git add/rm &lt;conflicted_files>", then run "git rebase --continue".
hint: You can instead skip this commit: run "git rebase --skip".
hint: To abort and get back to the state before "git rebase", run "git rebase --abort".
Could not apply 9ca04ea... Hello uses Greeter
</code></pre><p>Ut, oh! We have the same conflict during this rebase that we resolved earlier. This is a great example of why it can be tricky to mix rebasing and merging together.<p>Resolve the conflict by updating <code>lib/hello.rb</code> with the expected content:<pre><code>require_relative 'greeter'

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
</code></pre><p>Then continue through the rebase:<pre><code>> git add lib/hello.rb
> git rebase --continue
</code></pre><pre><code class=language-output>> git add lib/hello.rb
> git rebase --continue
[detached HEAD 630033d] Hello uses Greeter
1 file changed, 4 insertions(+), 1 deletion(-)
Successfully rebased and updated refs/heads/greet.
</code></pre><h2>Check the history</h2><p>Finally, run <code>git hist</code> again to see what's happened to our "Add a thank you" commit.<pre><code>> git hist
</code></pre><pre><code class=language-output>> git hist
* 630033d 2022-08-16 | Hello uses Greeter (HEAD -> greet) [Brenton Cleeland]
* 55d0c6b 2022-08-16 | Added greeter class [Brenton Cleeland]
* f6a7d74 2022-08-16 | Add a thank you to Jim (main) [Brenton Cleeland]
* ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
* 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Notice that our "Add a thank you" commit has moved before the new commits on our <code>greet</code> branch. This has made our commit history completely linear.<h2>Merge VS Rebase</h2><p>The final result of the rebase is very similar to the merge.<p>The greet branch now contains all of its changes, as well as all the changes from the main branch. However, the commit tree is quite different.<p>The commit tree for the greet branch has been rewritten so that the main branch is a part of the commit history. This leaves the chain of commits linear and much easier to read.<h2>When to Rebase, When to Merge?</h2><p>Don’t use rebase...<ul><li>If the branch is public and shared with others. Rewriting publicly shared branches will tend to screw up other members of the team.<li>When the exact history of the commit branch is important (since rebase rewrites the commit history).</ul><p>Given the above guidelines, I tend to use rebase for short-lived, local branches and merge for branches in the public repository.<p>Next: <a href="#LAB-30: Merging Back to Main"class="portal inline">LAB-30: Merging Back to Main</a></div><div class=page id="LAB-30: Merging Back to Main"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-30: Merging Back to Main</span></div><h2>Merge greet into main</h2><p>We’ve kept our greet branch up to date with main (via rebase), now let’s merge the greet changes back into the main branch.<pre><code>> git checkout main
> git merge greet
</code></pre><pre><code class=language-output>> git checkout main
Switched to branch 'main'
> git merge greet
Updating f6a7d74..630033d
Fast-forward
lib/greeter.rb | 8 ++++++++
lib/hello.rb   | 5 ++++-
2 files changed, 12 insertions(+), 1 deletion(-)
create mode 100644 lib/greeter.rb
</code></pre><p>Because the head of main is a direct ancestor of the head of the greet branch, git is able to do a fast-forward merge. When fast-forwarding, the branch pointer is simply moved forward to point to the same commit as the greeter branch.<p>There will never be conflicts in a fast-forward merge.<h2>Review the logs</h2><pre><code>git hist
</code></pre><pre><code class=language-output>> git hist
* 630033d 2022-08-16 | Hello uses Greeter (HEAD -> main, greet) [Brenton Cleeland]
* 55d0c6b 2022-08-16 | Added greeter class [Brenton Cleeland]
* f6a7d74 2022-08-16 | Add a thank you to Jim [Brenton Cleeland]
* ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
* 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>The greet and main branches are now identical.<p>Next: <a href="#LAB-31: Multiple Repositories"class="portal inline">LAB-31: Multiple Repositories</a></div><div class=page id="LAB-31: Multiple Repositories"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-31: Multiple Repositories</span></div><h2>Multiple Repositories</h2><p>Up to this point we have been working with a single git repository. However, git excels at working with multiple repositories. These extra repositories may be stored locally, or may be accessed across a network connection. In modern workflows you will use a hosted remote repository (i.e. on Github or Azure DevOps) as a way of sharing your code with other developers on your team.<p>In the next section we will create a new repository called “cloned_hello”. We will show how to move changes from one repository to another, and how to handle conflicts when they arise between two repositories.<p><img alt="Image representing the hello repository with a cloned_hello copy of the repository"src=https://media.brntn.me/postie/2ca6c24a.png><p>For now, we will be working with local repositories (i.e. repositories stored on your local hard disk), however most of the things learned in this section will apply to multiple repositories whether they are stored locally or remotely over a network.<p><strong>NOTE:</strong> We are going be making changes to both copies of our repositories. Make sure you pay attention to which repository you are in at each step of the following labs.<p>Next: <a href="#LAB-32: Cloning Repositories"class="portal inline">LAB-32: Cloning Repositories</a></div><div class=page id="LAB-32: Cloning Repositories"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-32: Cloning Repositories</span></div><h2>Cloning Repositories</h2><p>First, we need to move up one directory in our terminal.<pre><code>> cd ..
> ls
</code></pre><p>In the output of <code>ls</code> you should see your <code>hello</code> directory.<pre><code class=language-output>> ls
hello
</code></pre><h2>Create a clone of the hello repository</h2><p>Let's make a clone of the repository.<pre><code>> git clone hello cloned_hello
> ls
</code></pre><pre><code class=language-output>> git clone hello cloned_hello
Cloning into 'cloned_hello'...
done.
> ls
cloned_hello hello
</code></pre><p>There should now be two repositories in your working directory: the original “hello” repository and the newly cloned “cloned_hello” repository.<p>Next: <a href="#LAB-33: Review the Cloned Repository"class="portal inline">LAB-33: Review the Cloned Repository</a></div><div class=page id="LAB-33: Review the Cloned Repository"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-33: Review the Cloned Repository</span></div><h2>Look at the cloned repository</h2><p>Let’s take a look at the cloned repository.<pre><code>> cd cloned_hello
> ls
</code></pre><pre><code class=language-output>> ls
README.md lib
</code></pre><p>You should see a list of all the files in the top level of the original repository (README and lib). You've created a complete copy of the "hello" repository.<h2>Review the repository history</h2><pre><code>> git hist --all
</code></pre><pre><code class=language-output>* 630033d 2022-08-16 | Hello uses Greeter (HEAD -> main, origin/main, origin/greet, origin/HEAD) [Brenton Cleeland]
* 55d0c6b 2022-08-16 | Added greeter class [Brenton Cleeland]
* f6a7d74 2022-08-16 | Add a thank you to Jim [Brenton Cleeland]
* ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
* 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>You should now see a list of all the commits in the new repository, and it should (more or less) match the history of commits in the original repository. The only difference should be in the names of the branches.<p>You can see the main branch (along with HEAD) in the history list. But you will also have a number of strangely named branches (origin/main, origin/greet and origin/HEAD). We’ll talk about those in a bit.<p>Next: <a href="#LAB-34: What is Origin"class="portal inline">LAB-34: What is Origin</a></div><div class=page id="LAB-34: What is Origin"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-34: What is Origin</span></div><h2>What is Origin?</h2><p>Let's learn a little about naming remote repositories.<pre><code>> git remote
</code></pre><pre><code class=language-output>> git remote
origin
</code></pre><p>We see that the cloned repository knows about a remote repository named origin. Let’s see if we can get more information about origin:<pre><code>> git remote show origin
</code></pre><pre><code class=language-output>* remote origin
Fetch URL: /Users/brecleel/Dev/hello
Push  URL: /Users/brecleel/Dev/hello
HEAD branch: main
Remote branches:
    greet tracked
    main  tracked
Local branch configured for 'git pull':
    main merges with remote main
Local ref configured for 'git push':
    main pushes to main (up to date)
</code></pre><p>Now we see that the remote repository “origin” is simply the original hello repository on our filesystem.<p>Remote repositories typically live on a separate machine, possibly a centralized server. As we can see here, however, they can just as well point to a repository on the same machine.<p>There is nothing particularly special about the name “origin”, however the convention is to use the name “origin” for the primary centralized repository (if there is one).<p>Next: <a href="#LAB-35: Remote Branches"class="portal inline">LAB-35: Remote Branches</a></div><div class=page id="LAB-35: Remote Branches"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-35: Remote Branches</span></div><h2>Remote Branches</h2><p>Let's look at the branches available in our cloned repository.<pre><code>> git branch
</code></pre><pre><code class=language-output>> git branch
* main
</code></pre><p>That's it! Only the main branch is listed. Where is the greet branch? The <code>git branch</code> command only lists the local branches by default.<h2>Listing remote branches</h2><p>To see all branches you need to use the <code>-a</code> flag on <code>git branch</code>.<pre><code>> git branch -a
</code></pre><pre><code class=language-output>* main
remotes/origin/HEAD -> origin/main
remotes/origin/greet
remotes/origin/main
</code></pre><p>Git has all the commits from the original repository, but branches in the remote repository are not treated as local branches here. If we want our own greet branch, we need to create it ourselves. We will see how to do that in a minute.<p>Next: <a href="#LAB-36: Change the Original Repository"class="portal inline">LAB-36: Change the Original Repository</a></div><div class=page id="LAB-36: Change the Original Repository"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-36: Change the Original Repository</span></div><h2>Make a change in the original hello repository</h2><p>First, move back into the origin <code>hello</code> repository.<pre><code>> cd ../hello
</code></pre><p>Now, make a change to the README.md file:<pre><code>This is the Hello World example from the git tutorial.

Thanks to Jim Weirich for the initial work on this tutorial for RailsConf 2010.

(changed in original)
</code></pre><p>Add and commit the change.<pre><code>> git add README.md
> git commit -m "Changed README in the original repo"
</code></pre><h2>Up Next</h2><p>The original repository now has later changes that are not in the cloned version. Next we will pull those changes across to the cloned repository.<p>Next: <a href="#LAB-37: Fetching Changes"class="portal inline">LAB-37: Fetching Changes</a></div><div class=page id="LAB-37: Fetching Changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-37: Fetching Changes</span></div><h2>Fetching Changes</h2><p>Move into the <code>cloned_hello</code> repository and check the history.<pre><code>> cd ../cloned_hello
> git hist --all
</code></pre><pre><code class=language-output>> cd ../cloned_hello/
> git hist --all
* 630033d 2022-08-16 | Hello uses Greeter (HEAD -> main, origin/main, origin/greet, origin/HEAD) [Brenton Cleeland]
* 55d0c6b 2022-08-16 | Added greeter class [Brenton Cleeland]
* f6a7d74 2022-08-16 | Add a thank you to Jim [Brenton Cleeland]
* ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
* 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>Notice that the new "Changed README in origin repo" commit isn't yet available in this repository.<h2>Fetching changes from origin</h2><p>The <code>git fetch</code> command is used to retrieve the latest version of the repository from our remote.<pre><code>> git fetch
> git hist --all
</code></pre><pre><code class=language-output>> git fetch
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 333 bytes | 111.00 KiB/s, done.
From /Users/brecleel/Dev/hello
630033d..35263dc  main       -> origin/main
> git hist --all
* 35263dc 2022-08-17 | Changed README in the original repo (origin/main, origin/HEAD) [Brenton Cleeland]
* 630033d 2022-08-16 | Hello uses Greeter (HEAD -> main, origin/greet) [Brenton Cleeland]
* 55d0c6b 2022-08-16 | Added greeter class [Brenton Cleeland]
* f6a7d74 2022-08-16 | Add a thank you to Jim [Brenton Cleeland]
* ef40b54 2022-08-16 | Made interactive [Brenton Cleeland]
* 22d8379 2022-08-16 | Added README.md [Brenton Cleeland]
* 41ff07c 2022-08-16 | Moved hello.rb to lib [Brenton Cleeland]
* af90521 2022-08-16 | Add an author/email comment [Brenton Cleeland]
* db1f4d1 2022-08-16 | Added a comment (tag: v1) [Brenton Cleeland]
* cebd1e7 2022-08-16 | Added a default value (tag: v1-beta) [Brenton Cleeland]
* 3f2c477 2022-08-16 | Using ARGV [Brenton Cleeland]
* 5dced27 2022-08-16 | First Commit [Brenton Cleeland]
</code></pre><p>At this point the repository has all the commits from the original repository, but they are not integrated into the cloned repository’s local branches.<p>Find the “Changed README in original repo” commit in the history above. Notice that the commit includes “origin/main” and “origin/HEAD”.<p>Now look at the “Hello uses Greeter” commit. You will see that the local main branch points to this commit, not to the new commit that we just fetched.<p>The upshot of this is that the <code>git fetch</code> command will fetch new commits from the remote repository, but it will not merge these commits into the local branches.<h2>Check the README</h2><p>We can demonstrate that the cloned README is unchanged.<pre><code>> cat README.md
</code></pre><pre><code class=language-output>This is the Hello World example from the git tutorial.

Thanks to Jim Weirich for the initial work on this tutorial for RailsConf 2010.
</code></pre><p>See, this is the original README.md contents from before we made our change in the <code>hello</code> repository.<p>Next: <a href="#LAB-38: Merging Pulled Changes"class="portal inline">LAB-38: Merging Pulled Changes</a></div><div class=page id="LAB-38: Merging Pulled Changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-38: Merging Pulled Changes</span></div><h2>Merge the fetch changes into local main</h2><p>The local and <code>origin</code> main branches are different, and you can use <code>git merge</code> to bring them into line.<pre><code>> git merge origin/main
</code></pre><pre><code class=language-output>> git merge origin/main
Updating 630033d..35263dc
Fast-forward
README.md | 2 ++
1 file changed, 2 insertions(+)
</code></pre><h2>Check the README again</h2><p>We should see the changes now.<pre><code>> cat README.md
</code></pre><pre><code class=language-output>> cat README.md
This is the Hello World example from the git tutorial.

Thanks to Jim Weirich for the initial work on this tutorial for RailsConf 2010.

(changed in original)
</code></pre><h2>Pulling changes (instead of fetching them)</h2><p>We’re not going to go through the process of creating another change and merging it again, but we do want you to know that doing:<pre><code>> git pull
</code></pre><p>Is the equivalent of doing the two steps we just did in a single command.<pre><code>> git fetch
> git merge origin/main
</code></pre><p>Next: <a href="#LAB-39: Create a bare repository"class="portal inline">LAB-39: Create a bare repository</a></div><div class=page id="LAB-39: Create a bare repository"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-39: Create a bare repository</span></div><h2>Create a bare repository</h2><p>In order to push a change to a remote, the remote needs to be a "bare" repository. Bare repositories don't have working directories, and a effectively just the content of the <code>.git</code> directory. When you create a repository with a service like Github the repository that they host will be considered bare (though it might not look like it in the user interface).<p>Let's create a bare repository from our <code>hello</code> repository.<pre><code>> cd ..
> git clone --bare hello hello.git
> ls hello.git
</code></pre><pre><code class=language-output>> git clone --bare hello hello.git
Cloning into bare repository 'hello.git'...
done.
> ls hello.git
HEAD        config      description hooks       info        objects     packed-refs refs
</code></pre><p>The convention is that repositories ending in ‘.git’ are bare repositories. We can see that there is no working directory in the hello.git repo. Essentially it is nothing but the .git directory of a non-bare repo.<h2>Add the new remote to <code>cloned_hello</code></h2><p>Move back into the cloned_hello repository and add our new bare repository as a remote.<pre><code>cd cloned_hello
git remote add shared ../hello.git
</code></pre><p>We've named the remote "shared" in the command above.<p>Next: <a href="#LAB-40: Push a change"class="portal inline">LAB-40: Push a change</a></div><div class=page id="LAB-40: Push a change"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-40: Push a change</span></div><h2>Make a change to our <code>cloned_hello</code> repo</h2><p>Let's push a change to our new bare remote.<p>Update the README.md in your <code>cloned_hello</code> repository:<pre><code>This is the Hello World example from the git tutorial.

Thanks to Jim Weirich for the initial work on this tutorial for RailsConf 2010.

(changed in original, then changed in cloned_hello)
</code></pre><p>Add and commit the change using the commands you've learned today.<pre><code>> git add README.md
> git commit -m "Update README from our cloned repo"
</code></pre><pre><code class=language-output>> git commit -m "Update README from our cloned repo"
[main 1dc8db6] Update README from our cloned repo
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><h2>Use <code>git push</code> to publish our change</h2><p>In the command below "shared" is the name of our remote, and "main" is the name of the branch we are pushing. It's possible to set up branches to "track" remote branches automatically (allowing you to simply <code>git push</code>) but being explicit about where and what your are pushing is good practice.<pre><code>> git push shared main
</code></pre><pre><code class=language-output>git push shared main
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 8 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 364 bytes | 364.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
To ../hello.git
35263dc..1dc8db6  main -> main
</code></pre><p>Your change has now been pushed to the remote and is shared with others.<p>Next: <a href="#LAB-41: Pulling shared changes"class="portal inline">LAB-41: Pulling shared changes</a></div><div class=page id="LAB-41: Pulling shared changes"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-41: Pulling shared changes</span></div><h2>Pulling shared changes</h2><p>Let's quickly hop over into the origin "hello" repository and pull the changes from the bare repository. At this point all of the commands below should be familiar.<pre><code>> cd ../hello
> git remote add shared ../hello.git
> git pull shared main
> cat README.md
</code></pre><pre><code class=language-output>> cd ../hello
> git remote add shared ../hello.git
> git pull shared main
From ../hello
* branch            main       -> FETCH_HEAD
* [new branch]      main       -> shared/main
Updating 35263dc..1dc8db6
Fast-forward
README.md | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)
> cat README.md
This is the Hello World example from the git tutorial.

Thanks to Jim Weirich for the initial work on this tutorial for RailsConf 2010.

(changed in original, then changed in cloned_hello)
</code></pre><p>Because we used <code>git pull</code> the changes from the remote were automatically merged into our <code>main</code> branch. Both the <code>hello</code> and <code>cloned_hello</code> repositories are now in sync.<p>Next: <a href="#LAB-42: Hosting your repository on Github"class="portal inline">LAB-42: Hosting your repository on Github</a></div><div class=page id="LAB-42: Hosting your repository on Github"><div class=breadcrumbs><a href=#>home</a> / <span>LAB-42: Hosting your repository on Github</span></div><h2>Create a new repository on Github</h2><p>Sign in to the account you created earlier and create a new repository on <a href=https://github.com class=external target=_blank>Github</a>. Choose a name for your repo (I chose "hello" but you can choose anything you like).<p><img alt="Screenshot of the new repository screen on Github, with the name hello being used for the repo"src=https://media.brntn.me/postie/1464c443.png><h2>Add the new repository as a remote</h2><p>From the empty repository screen, copy the SSH URL for the repository. It should look similar to <code>git@github.com:brntn-ps/hello.git</code> but with your username instead of mine.<p><img alt="Screenshot of an empty repository on Github"src=https://media.brntn.me/postie/db70b59c.png><p>Add the repository as a remote for our hello repo.<pre><code>> git remote add github git@github.com:brntn-ps/hello.git
</code></pre><h2>Push our code to the remote</h2><p>Using the same <code>git push</code> command as we did before, we'll push our code to the new <code>github</code> remote.<pre><code>> git push github main
</code></pre><pre><code class=language-output>git push github main
Enumerating objects: 41, done.
Counting objects: 100% (41/41), done.
Delta compression using up to 8 threads
Compressing objects: 100% (32/32), done.
Writing objects: 100% (41/41), 3.91 KiB | 572.00 KiB/s, done.
Total 41 (delta 4), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (4/4), done.
To github.com:brntn-ps/hello.git
* [new branch]      main -> main
</code></pre><p>If you navigate to the repository in your browser and refresh, you should now see our code.<p>Next: <a href="#Next steps with Git"class="portal inline">Next steps with Git</a></div><div class=page id="Next steps with Git"><div class=breadcrumbs><a href=#>home</a> / <span>Next steps with Git</span></div><h2>Next</h2><ul><li><a href=https://git-scm.com/book/en/v2 class=external target=_blank>Pro Git</a></ul></div><div class=page id=home><div class=breadcrumbs><span>home</span></div><h1>Git Immersion (2023 Edition)</h1><p>A guided tour that walks through the fundamentals of Git, inspired by the premise that to know a thing is to do it.<hr><p><code>git</code> is an industry standard version control system. Today's workshop will give you a deep dive into how to use it on a project.<p>Large parts of this tutorial are based on the <a href=https://github.com/edgecase/git_immersion class=external target=_blank>Git Immersion</a> tutorial which was originally presented at RailsConf 2010 by <a href=https://en.wikipedia.org/wiki/Jim_Weirich class=external target=_blank>Jim Weirich</a>. That tutorial is licensed as CC-BY-SA and this updated tutorial retains that license.<p>Changes from the original:<ul><li>Switch from <code>master</code> to <code>main</code> as the default branch<li>Use <code>restore</code> instead of <code>checkout</code> to roll back unstaged changes<li>Use <code>restore --staged</code> instead of <code>reset</code> to roll back staged changes<li>Remove steps that add the Rakefile to remove the dependency on having <code>ruby</code> available<li>Use <code>switch</code> instead of <code>checkout</code> to change branches<li>Create a new change to demonstrate the difference between merge and rebase, instead of resetting both branches<li>Round things out by pushing to a repository on Github</ul><h2>Lab Exercises</h2><a href="#LAB-01: Getting things installed"class=portal>LAB-01: Getting things installed</a><a href="#LAB-02: Github setup"class=portal>LAB-02: Github setup</a><a href="#LAB-03: Configure Git"class=portal>LAB-03: Configure Git</a><a href="#LAB-04: Create a Project"class=portal>LAB-04: Create a Project</a><a href="#LAB-05: Checking Status"class=portal>LAB-05: Checking Status</a><a href="#LAB-06: Making Changes"class=portal>LAB-06: Making Changes</a><a href="#LAB-07: Staging Changes"class=portal>LAB-07: Staging Changes</a><a href="#LAB-08: Staging and Committing"class=portal>LAB-08: Staging and Committing</a><a href="#LAB-09: Committing Changes"class=portal>LAB-09: Committing Changes</a><a href="#LAB-10: Changes, not Files"class=portal>LAB-10: Changes, not Files</a><a href="#LAB-11: History"class=portal>LAB-11: History</a><a href="#LAB-12: Aliases"class=portal>LAB-12: Aliases</a><a href="#LAB-13: Getting Old Versions"class=portal>LAB-13: Getting Old Versions</a><a href="#LAB-14: Tagging versions"class=portal>LAB-14: Tagging versions</a><a href="#LAB-15: Undoing Local Changes Before Staging"class=portal>LAB-15: Undoing Local Changes Before Staging</a><a href="#LAB-16: Undoing Local Changes Before Committing"class=portal>LAB-16: Undoing Local Changes Before Committing</a><a href="#LAB-17: Undoing Committed Changes"class=portal>LAB-17: Undoing Committed Changes</a><a href="#LAB-18: Removing Commits from a Branch"class=portal>LAB-18: Removing Commits from a Branch</a><a href="#LAB-19: Ammending Commits"class=portal>LAB-19: Ammending Commits</a><a href="#LAB-20: Moving Files"class=portal>LAB-20: Moving Files</a><a href="#LAB-21: Git Internals - The .git Directory"class=portal>LAB-21: Git Internals - The .git Directory</a><a href="#LAB-22: Creating a Branch"class=portal>LAB-22: Creating a Branch</a><a href="#LAB-23: Navigating Branches"class=portal>LAB-23: Navigating Branches</a><a href="#LAB-24: Changes in main"class=portal>LAB-24: Changes in main</a><a href="#LAB-25: Viewing Diverging Branches"class=portal>LAB-25: Viewing Diverging Branches</a><a href="#LAB-26: Merging"class=portal>LAB-26: Merging</a><a href="#LAB-27: Creating a Conflict"class=portal>LAB-27: Creating a Conflict</a><a href="#LAB-28: Resolving Conflicts"class=portal>LAB-28: Resolving Conflicts</a><a href="#LAB-29: Merging vs Rebasing"class=portal>LAB-29: Merging vs Rebasing</a><a href="#LAB-30: Merging Back to Main"class=portal>LAB-30: Merging Back to Main</a><a href="#LAB-31: Multiple Repositories"class=portal>LAB-31: Multiple Repositories</a><a href="#LAB-32: Cloning Repositories"class=portal>LAB-32: Cloning Repositories</a><a href="#LAB-33: Review the Cloned Repository"class=portal>LAB-33: Review the Cloned Repository</a><a href="#LAB-34: What is Origin"class=portal>LAB-34: What is Origin</a><a href="#LAB-35: Remote Branches"class=portal>LAB-35: Remote Branches</a><a href="#LAB-36: Change the Original Repository"class=portal>LAB-36: Change the Original Repository</a><a href="#LAB-37: Fetching Changes"class=portal>LAB-37: Fetching Changes</a><a href="#LAB-38: Merging Pulled Changes"class=portal>LAB-38: Merging Pulled Changes</a><a href="#LAB-39: Create a bare repository"class=portal>LAB-39: Create a bare repository</a><a href="#LAB-40: Push a change"class=portal>LAB-40: Push a change</a><a href="#LAB-41: Pulling shared changes"class=portal>LAB-41: Pulling shared changes</a><a href="#LAB-42: Hosting your repository on Github"class=portal>LAB-42: Hosting your repository on Github</a><a href="#Next steps with Git"class=portal>Next steps with Git</a><hr><p>This version of Git Immersion was updated in 2022 by Brenton Cleeland for Publicis Sapient Australia for our Early Careers program. Like the original, it is released under a <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ class=external target=_blank>Creative Commons Attribution Non-Commercial Share-Alike 4.0 International</a> license.</div></div></div>